<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>8 Regine - Visual</title>
    <style>
        :root {
            --bg-color: #2c3e50;
            --board-border: #34495e;
            --white-cell: #ecf0f1;
            --black-cell: #95a5a6;
            --unsafe-overlay: rgba(231, 76, 60, 0.25); /* Rosso tenue per le zone minacciate */
            --conflict-color: #c0392b; /* Rosso scuro per l'errore grave */
            --hint-color: #27ae60; /* Verde per il suggerimento */
            --btn-reset: #e74c3c;
            --btn-help: #f39c12;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
        }

        h1 { margin: 10px 0; font-size: 1.8rem; }
        p { margin-bottom: 15px; color: #bdc3c7; font-size: 0.9rem; }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        /* Controlli SOPRA la scacchiera */
        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 5px;
        }

        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            transition: transform 0.1s, opacity 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
        }

        button:active { transform: translateY(2px); }

        .btn-reset { background-color: var(--btn-reset); color: white; }
        .btn-help { background-color: var(--btn-help); color: #2c3e50; }

        /* Scacchiera */
        .board {
            display: grid;
            grid-template-columns: repeat(8, 55px);
            grid-template-rows: repeat(8, 55px);
            border: 8px solid var(--board-border);
            border-radius: 4px;
            user-select: none;
            background-color: var(--board-border);
            gap: 1px; /* Piccola griglia tra le celle */
        }

        .cell {
            width: 55px;
            height: 55px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
            cursor: pointer;
            position: relative;
            background-color: var(--white-cell);
            color: #2c3e50;
            transition: background-color 0.2s;
        }

        /* Pattern scacchiera */
        .cell.black { background-color: var(--black-cell); }

        /* 1. Celle "bruciate" (minacciate da una regina esistente) */
        .cell.unsafe::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: var(--unsafe-overlay);
            z-index: 1;
            pointer-events: none; /* Permette il click sotto */
        }

        /* Indicatore visuale "X" molto sottile sulle celle bruciate (opzionale, per chiarezza) */
        .cell.unsafe::after {
            content: '√ó';
            position: absolute;
            font-size: 20px;
            color: rgba(192, 57, 43, 0.4);
            z-index: 1;
            pointer-events: none;
        }

        /* 2. Conflitto REALE (Regina su Regina) */
        .cell.conflict {
            background-color: var(--conflict-color) !important;
            color: white !important;
            animation: shake 0.4s;
            z-index: 2;
        }
        .cell.conflict::after { content: ''; } /* Rimuove la X sulle regine */

        /* 3. Suggerimento AI */
        .cell.hint {
            border: 3px solid var(--hint-color);
            box-sizing: border-box;
            background-color: rgba(39, 174, 96, 0.3);
            z-index: 3;
        }

        .status {
            min-height: 24px;
            font-weight: bold;
            color: #f1c40f;
            text-align: center;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-3px); }
            75% { transform: translateX(3px); }
        }

        /* Regina (carattere unicode) sopra a tutto */
        .queen-marker {
            z-index: 5;
            position: relative;
            pointer-events: none;
        }

    </style>
</head>
<body>

    <div class="game-container">
        <h1>8 Regine: Visual Puzzle</h1>
        
        <div class="controls">
            <button class="btn-reset" onclick="resetBoard()">üóëÔ∏è Ricomincia</button>
            <button class="btn-help" onclick="getOneStepHelp()">üí° Aiutami (1 Passo)</button>
        </div>

        <div class="status" id="statusMsg">Posiziona 8 regine...</div>

        <div id="board" class="board"></div>
    </div>

    <script>
        const N = 8;
        let queens = []; // Array di oggetti {r, c}

        function initGame() {
            const boardEl = document.getElementById('board');
            boardEl.innerHTML = '';
            for (let r = 0; r < N; r++) {
                for (let c = 0; c < N; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.classList.add((r + c) % 2 === 0 ? 'white' : 'black');
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    // Evento click
                    cell.onclick = () => toggleQueen(r, c);
                    boardEl.appendChild(cell);
                }
            }
            queens = [];
            updateBoardVisuals();
        }

        function toggleQueen(r, c) {
            const index = queens.findIndex(q => q.r === r && q.c === c);
            
            if (index >= 0) {
                // Rimuovi se c'√® gi√†
                queens.splice(index, 1);
            } else {
                // Se c'√® gi√† una regina su questa riga, la spostiamo invece di aggiungerne una seconda (UX migliore)
                const rowQueenIndex = queens.findIndex(q => q.r === r);
                if (rowQueenIndex >= 0) {
                    queens.splice(rowQueenIndex, 1);
                }
                queens.push({r, c});
            }
            
            document.getElementById('statusMsg').innerText = "";
            updateBoardVisuals();
            checkVictory();
        }

        function updateBoardVisuals() {
            const cells = document.querySelectorAll('.cell');
            
            // 1. Reset visuale
            cells.forEach(c => {
                c.innerHTML = '';
                c.classList.remove('unsafe', 'conflict', 'hint');
            });

            // 2. Calcola tutte le celle "minacciate" (Unsafe)
            // Mappa delle celle attaccate globalmente
            let attackedCells = new Set();
            
            queens.forEach(q => {
                // Per ogni regina, calcoliamo le sue linee di tiro
                for(let r=0; r<N; r++) {
                    for(let c=0; c<N; c++) {
                        if (r === q.r || c === q.c || Math.abs(r - q.r) === Math.abs(c - q.c)) {
                            // Chiave univoca per la cella
                            attackedCells.add(`${r},${c}`); 
                        }
                    }
                }
            });

            // Applichiamo la classe 'unsafe' a tutte le celle attaccate
            // Nota: applichiamo unsafe anche dove c'√® la regina stessa, ma poi la regina ci va sopra
            attackedCells.forEach(key => {
                const [r, c] = key.split(',');
                const cell = document.querySelector(`.cell[data-row='${r}'][data-col='${c}']`);
                if(cell) cell.classList.add('unsafe');
            });

            // 3. Disegna le Regine e rileva Conflitti diretti
            queens.forEach((q1, i) => {
                const cell = document.querySelector(`.cell[data-row='${q1.r}'][data-col='${q1.c}']`);
                
                // Disegna simbolo
                const span = document.createElement('span');
                span.classList.add('queen-marker');
                span.innerText = '‚ôõ';
                cell.appendChild(span);

                // Controllo collisioni (Regina vs Regina)
                let isConflict = false;
                queens.forEach((q2, j) => {
                    if (i !== j) {
                        if (q1.r === q2.r || q1.c === q2.c || Math.abs(q1.r - q2.r) === Math.abs(q1.c - q2.c)) {
                            isConflict = true;
                        }
                    }
                });

                if (isConflict) {
                    cell.classList.add('conflict');
                    // Rimuovi unsafe per pulizia visiva sul conflitto (vince il rosso scuro)
                    cell.classList.remove('unsafe');
                } else {
                    // La cella dove sta una regina valida non deve sembrare "bruciata", ma occupata
                    cell.classList.remove('unsafe');
                }
            });
        }

        // --- Logica AI Backtracking ---

        function getOneStepHelp() {
            const msg = document.getElementById('statusMsg');
            msg.innerText = "";

            // 1. Controlla conflitti esistenti
            if (hasDirectConflicts()) {
                msg.innerText = "‚ö†Ô∏è Ci sono conflitti rossi da risolvere prima!";
                return;
            }

            if (queens.length === N) {
                msg.innerText = "üéâ Scacchiera completata!";
                return;
            }

            // 2. Cerca soluzione
            const solution = solve(queens);

            if (solution) {
                // Trova la prima riga libera
                for (let r = 0; r < N; r++) {
                    if (!queens.some(q => q.r === r)) {
                        const correctCol = solution[r];
                        
                        // Aggiunge la mossa
                        queens.push({r: r, c: correctCol});
                        updateBoardVisuals();

                        // Highlight verde
                        const cell = document.querySelector(`.cell[data-row='${r}'][data-col='${correctCol}']`);
                        if(cell) cell.classList.add('hint');
                        
                        return;
                    }
                }
            } else {
                msg.innerText = "‚õî Nessuna soluzione possibile da qui. Togli l'ultima regina.";
            }
        }

        function hasDirectConflicts() {
            for(let i=0; i<queens.length; i++) {
                for(let j=i+1; j<queens.length; j++) {
                    let q1 = queens[i];
                    let q2 = queens[j];
                    if (q1.r === q2.r || q1.c === q2.c || Math.abs(q1.r - q2.r) === Math.abs(q1.c - q2.c)) {
                        return true;
                    }
                }
            }
            return false;
        }

        // Backtracking Solver
        function solve(currentQueens) {
            let board = new Array(N).fill(-1);
            
            // Fissa le regine attuali
            for(let q of currentQueens) board[q.r] = q.c;

            function solveRecursive(row) {
                if (row === N) return true; 

                // Se riga gi√† occupata dall'utente, salta
                if (board[row] !== -1) return solveRecursive(row + 1);

                for (let col = 0; col < N; col++) {
                    if (isSafe(board, row, col)) {
                        board[row] = col;
                        if (solveRecursive(row + 1)) return true;
                        board[row] = -1; 
                    }
                }
                return false;
            }

            if (solveRecursive(0)) return board;
            return null;
        }

        function isSafe(board, row, col) {
            for (let i = 0; i < N; i++) {
                if (board[i] !== -1) { // controlla solo righe piazzate
                    let r = i;
                    let c = board[i];
                    // Controlliamo l'interferenza con la nuova posizione (row, col)
                    // Nota: Non serve controllare r == row perch√© il loop √® sulle righe precedenti o fissate
                    if (c === col || Math.abs(row - r) === Math.abs(col - c)) {
                        return false;
                    }
                }
            }
            return true;
        }

        function checkVictory() {
            if (queens.length === N && !hasDirectConflicts()) {
                document.getElementById('statusMsg').innerText = "üèÜ COMPLIMENTI! HAI VINTO! üèÜ";
            }
        }

        function resetBoard() {
            queens = [];
            document.getElementById('statusMsg').innerText = "Posiziona 8 regine...";
            updateBoardVisuals();
        }

        // Avvio
        initGame();

    </script>
</body>
</html>
